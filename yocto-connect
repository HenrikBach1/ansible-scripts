#!/bin/bash
# Simplified Yocto container connection script
# Uses unified container-shell-setup.sh for all functionality

CONTAINER_NAME="${1:-yocto_container}"

# Check if container exists
if ! docker ps -a --format '{{.Names}}' | grep -w "^$CONTAINER_NAME$" > /dev/null; then
    echo "Container '$CONTAINER_NAME' does not exist"
    exit 1
fi

# Check if container is running
if ! docker ps --format '{{.Names}}' | grep -w "^$CONTAINER_NAME$" > /dev/null; then
    echo "Container '$CONTAINER_NAME' is not running"
    echo "Starting container..."
    docker start "$CONTAINER_NAME"
    sleep 1
fi

# Check if container environment is set up, if not run setup
if ! docker exec "$CONTAINER_NAME" test -f "/usr/local/bin/container-help" 2>/dev/null; then
    echo "Container environment not found, setting up..."
    
    # Copy the unified setup script to container
    docker cp "$(dirname "$0")/container-shell-setup.sh" "$CONTAINER_NAME:/tmp/container-shell-setup.sh"
    
    # Run the setup script inside the container as root to ensure system-wide installation
    docker exec -u root "$CONTAINER_NAME" bash /tmp/container-shell-setup.sh
    
    # Also run as regular user to set up user-specific files (.shrc, etc.)
    docker exec "$CONTAINER_NAME" bash /tmp/container-shell-setup.sh
else
    echo "Container environment already configured."
fi

# Connect to container with enhanced environment
echo "Connecting to $CONTAINER_NAME..."
docker exec -it "$CONTAINER_NAME" bash -c "
# Source the shell environment (for immediate use)
export PATH=\"\$HOME/bin:/tmp/.container_commands:\$PATH\"

# Set proper prompt
if [ -n \"\$BASH_VERSION\" ]; then
    export PS1=\"\\[\\033[01;32m\\]\\u@\\[\\033[00m\\]\\[\\033[01;33m\\](yocto)\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ \"
fi

# Set up convenient aliases
alias detach='container-detach'
alias stop='container-stop'
alias help='container-help'

# Set up monitoring for container control commands
monitor_container_requests() {
    while true; do
        if [ -f \$HOME/.container_detach_requested ] || [ -f /tmp/.container_detach_requested ]; then
            echo 'Detach requested, exiting...'
            rm -f \$HOME/.container_detach_requested /tmp/.container_detach_requested 2>/dev/null || true
            exit 0
        elif [ -f \$HOME/.container_stop_requested ] || [ -f /tmp/.container_stop_requested ]; then
            echo 'Stop requested, exiting...'
            rm -f \$HOME/.container_stop_requested /tmp/.container_stop_requested 2>/dev/null || true
            exit 1
        elif [ -f \$HOME/.container_remove_requested ] || [ -f /tmp/.container_remove_requested ]; then
            echo 'Remove requested, exiting...'
            rm -f \$HOME/.container_remove_requested /tmp/.container_remove_requested 2>/dev/null || true
            exit 2
        fi
        sleep 0.1
    done
}

# Start monitoring in background
monitor_container_requests &
MONITOR_PID=\$!

# Clean up monitor on exit
trap 'kill \$MONITOR_PID 2>/dev/null || true' EXIT

echo \"Welcome to the Yocto Container!\"
echo \"Enhanced environment with container commands available.\"
echo \"Type 'help' or 'container-help' for available commands.\"
echo \"\"

# Start interactive bash session with login profile
exec bash --login
"

# Handle exit codes for container management
EXIT_CODE=$?
case $EXIT_CODE in
    0)
        echo "Container detached and still running."
        ;;
    1)
        echo "Stopping container $CONTAINER_NAME..."
        docker stop "$CONTAINER_NAME" > /dev/null
        echo "Container stopped."
        ;;
    2)
        echo "Removing container $CONTAINER_NAME..."
        docker rm -f "$CONTAINER_NAME" > /dev/null
        echo "Container removed."
        ;;
    *)
        echo "Container session ended."
        ;;
esac

exit 0
